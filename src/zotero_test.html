<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Zotero Citation Network</title>
    <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        height: 100vh;
        overflow: hidden;
      }
      h1 {
        color: #333;
        margin: 0 0 5px 0;
        font-size: 24px;
      }
      .subtitle {
        color: #666;
        margin: 0;
        font-size: 14px;
      }
      .top-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }
      .mode-selector {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .mode-selector label {
        font-size: 14px;
        color: #666;
      }
      .mode-selector select {
        padding: 8px 12px;
        font-size: 14px;
        border: 1px solid #ccc;
        border-radius: 4px;
        background: #fff;
        cursor: pointer;
      }
      .mode-selector select:focus {
        outline: none;
        border-color: #cc2936;
      }
      .container {
        display: flex;
        gap: 20px;
        height: calc(100vh - 120px);
      }

      /* Left panel - item list */
      .left-panel {
        width: 350px;
        flex-shrink: 0;
        display: flex;
        flex-direction: column;
        border: 1px solid #ccc;
        border-radius: 8px;
        background: #fff;
      }
      .search-box {
        padding: 10px;
        border-bottom: 1px solid #eee;
      }
      .search-box input {
        width: 100%;
        padding: 10px 12px;
        font-size: 14px;
        border: 1px solid #ddd;
        border-radius: 4px;
      }
      .search-box input:focus {
        outline: none;
        border-color: #cc2936;
      }
      .list-header {
        padding: 10px 15px;
        background: #f5f5f5;
        border-bottom: 1px solid #eee;
        font-size: 12px;
        color: #666;
      }
      .item-list {
        flex: 1;
        overflow-y: auto;
        padding: 0;
        margin: 0;
        list-style: none;
      }
      .item-list li {
        padding: 12px 15px;
        border-bottom: 1px solid #eee;
        cursor: pointer;
        transition: background 0.15s;
      }
      .item-list li:hover {
        background: #f5f5f5;
      }
      .item-list li.selected {
        background: #fff0f0;
        border-left: 3px solid #cc2936;
      }
      .item-list li.no-refs {
        opacity: 0.5;
      }
      .item-title {
        font-size: 13px;
        color: #333;
        margin-bottom: 4px;
        line-height: 1.3;
      }
      .item-meta {
        font-size: 11px;
        color: #888;
      }
      .item-refs {
        font-size: 10px;
        color: #cc2936;
        margin-top: 3px;
      }
      .item-count {
        font-size: 10px;
        color: #cc2936;
        margin-top: 3px;
      }

      /* Right panel - graph */
      .right-panel {
        flex: 1;
        display: flex;
        flex-direction: column;
        border: 1px solid #ccc;
        border-radius: 8px;
        background: #fafafa;
        overflow: hidden;
      }
      .graph-header {
        padding: 15px;
        background: #fff;
        border-bottom: 1px solid #eee;
      }
      .graph-title {
        font-size: 14px;
        font-weight: bold;
        color: #333;
        margin-bottom: 5px;
      }
      .graph-subtitle {
        font-size: 12px;
        color: #666;
      }
      #cy {
        flex: 1;
        width: 100%;
      }
      .graph-legend {
        padding: 10px 15px;
        background: #fff;
        border-top: 1px solid #eee;
        display: flex;
        gap: 20px;
        font-size: 12px;
      }
      .legend-item {
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .legend-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
      }
      .legend-central {
        background-color: #cc2936;
        border: 2px solid #333;
      }
      .legend-library {
        background-color: #cc2936;
      }
      .legend-external {
        background-color: #b0b0b0;
      }

      /* Loading and status messages */
      .status-message {
        padding: 15px;
        text-align: center;
        color: #666;
      }
      .loading {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        color: #666;
      }
      .loading-spinner {
        width: 40px;
        height: 40px;
        border: 3px solid #eee;
        border-top-color: #cc2936;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 15px;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      .error {
        color: #d32f2f;
        padding: 20px;
        background-color: #ffebee;
        margin: 20px;
        border-radius: 4px;
      }

      /* Empty state */
      .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        color: #999;
        text-align: center;
        padding: 40px;
      }
      .empty-state svg {
        width: 80px;
        height: 80px;
        margin-bottom: 20px;
        opacity: 0.3;
      }

      /* Node info tooltip */
      #node-info {
        display: none;
        position: absolute;
        bottom: 20px;
        right: 20px;
        width: 280px;
        padding: 15px;
        background: white;
        border: 1px solid #ccc;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
        z-index: 100;
      }
      #node-info h3 {
        margin: 0 0 8px 0;
        font-size: 13px;
        line-height: 1.3;
      }
      #node-info p {
        margin: 4px 0;
        font-size: 11px;
        color: #666;
      }
      #node-info .close-btn {
        position: absolute;
        top: 8px;
        right: 12px;
        cursor: pointer;
        font-size: 18px;
        color: #999;
      }
      #node-info .close-btn:hover {
        color: #333;
      }
    </style>
  </head>
  <body>
    <div class="top-bar">
      <div>
        <h1>Zotero Network Visualizer</h1>
        <p class="subtitle">Explore citation and co-authorship networks in your library</p>
      </div>
      <div class="mode-selector">
        <label for="mode-select">Mode:</label>
        <select id="mode-select" onchange="switchMode(this.value)">
          <option value="citations">Citations</option>
          <option value="coauthorship">Co-authorship</option>
        </select>
      </div>
    </div>

    <div class="container">
      <!-- Left Panel: Item List -->
      <div class="left-panel">
        <div class="search-box">
          <input
            type="text"
            id="search-input"
            placeholder="Search..."
            oninput="filterList()"
          />
        </div>
        <div class="list-header" id="list-header">Loading library...</div>
        <ul class="item-list" id="item-list">
          <li class="loading">
            <div class="loading-spinner"></div>
            Loading...
          </li>
        </ul>
      </div>

      <!-- Right Panel: Graph -->
      <div class="right-panel">
        <div class="graph-header" id="graph-header" style="display: none;">
          <div class="graph-title" id="graph-title">Select an item</div>
          <div class="graph-subtitle" id="graph-subtitle">Click an item in the list to view its citation network</div>
        </div>
        <div id="cy">
          <div class="empty-state" id="empty-state">
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
            </svg>
            <div>Select an item from the list<br/>to view its citation network</div>
          </div>
        </div>
        <div class="graph-legend" id="graph-legend" style="display: none;">
          <span class="legend-item">
            <span class="legend-dot legend-central"></span>
            Selected Item
          </span>
          <span class="legend-item">
            <span class="legend-dot legend-library"></span>
            In Library
          </span>
          <span class="legend-item">
            <span class="legend-dot legend-external"></span>
            External
          </span>
        </div>
      </div>
    </div>

    <div id="node-info">
      <span class="close-btn" onclick="hideNodeInfo()">&times;</span>
      <h3 id="node-title"></h3>
      <p id="node-authors"></p>
      <p id="node-year"></p>
      <p id="node-type"></p>
    </div>

    <script>
      let cy = null;
      let currentMode = 'citations';

      // Citations mode data
      let allItems = [];
      let libraryWorkIds = new Set();
      let selectedItemId = null;

      // Co-authorship mode data
      let allAuthors = [];
      let selectedAuthorId = null;

      // Initialize on page load
      document.addEventListener('DOMContentLoaded', loadLibrary);

      function switchMode(mode) {
        currentMode = mode;
        selectedItemId = null;
        selectedAuthorId = null;

        // Clear the graph
        if (cy) {
          cy.destroy();
          cy = null;
        }

        // Reset graph header and legend
        document.getElementById('graph-header').style.display = 'none';
        document.getElementById('graph-legend').style.display = 'none';

        // Update search placeholder
        const searchInput = document.getElementById('search-input');
        searchInput.value = '';

        if (mode === 'citations') {
          searchInput.placeholder = 'Search by title or author...';
          document.getElementById('list-header').textContent = `${allItems.length} items with DOIs`;
          renderItemList(allItems);
          updateLegendForCitations();
        } else if (mode === 'coauthorship') {
          searchInput.placeholder = 'Search by author name...';
          if (allAuthors.length === 0) {
            loadAuthors();
          } else {
            document.getElementById('list-header').textContent = `${allAuthors.length} authors`;
            renderAuthorList(allAuthors);
            updateLegendForCoauthorship();
          }
        }
      }

      function updateLegendForCitations() {
        document.getElementById('graph-legend').innerHTML = `
          <span class="legend-item">
            <span class="legend-dot legend-central"></span>
            Selected Item
          </span>
          <span class="legend-item">
            <span class="legend-dot legend-library"></span>
            In Library
          </span>
          <span class="legend-item">
            <span class="legend-dot legend-external"></span>
            External
          </span>
        `;
      }

      function updateLegendForCoauthorship() {
        document.getElementById('graph-legend').innerHTML = `
          <span class="legend-item">
            <span class="legend-dot legend-central"></span>
            Selected Author
          </span>
          <span class="legend-item">
            <span class="legend-dot legend-library"></span>
            Co-author
          </span>
          <span class="legend-item" style="font-size: 11px; color: #666;">
            Edge width = number of shared papers
          </span>
        `;
      }

      async function loadLibrary() {
        try {
          const response = await fetch("/api/init-network", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
          });

          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || `HTTP error ${response.status}`);
          }

          const networkData = await response.json();

          // Store library work IDs for later reference
          libraryWorkIds = new Set(networkData.library_ids);

          // Store all items with their reference counts
          allItems = networkData.nodes.map(node => ({
            id: node.id,
            title: node.title,
            authors: node.authors,
            year: node.year,
            doi: node.doi,
            zoteroKey: node.zotero_key,
            refCount: 0  // Will be populated from edges
          }));

          // Count references for each item (outbound edges)
          const refCounts = {};
          networkData.edges.forEach(edge => {
            refCounts[edge.source] = (refCounts[edge.source] || 0) + 1;
          });
          allItems.forEach(item => {
            item.refCount = refCounts[item.id] || 0;
          });

          // Sort by title
          allItems.sort((a, b) => (a.title || '').localeCompare(b.title || ''));

          // Update header
          document.getElementById('list-header').textContent =
            `${allItems.length} items with DOIs`;

          // Render the list
          renderItemList(allItems);
          updateLegendForCitations();

        } catch (error) {
          console.error('Error loading library:', error);
          document.getElementById('item-list').innerHTML = `
            <div class="error">
              <strong>Error loading library:</strong><br/>
              ${error.message}<br/><br/>
              Make sure the Python proxy server is running and Zotero is open.
            </div>
          `;
        }
      }

      function renderItemList(items) {
        const listEl = document.getElementById('item-list');

        if (items.length === 0) {
          listEl.innerHTML = '<li class="status-message">No matching items</li>';
          return;
        }

        listEl.innerHTML = items.map(item => `
          <li
            data-id="${item.id}"
            class="${item.refCount === 0 ? 'no-refs' : ''}"
          >
            <div class="item-title">${sanitizeHtml(item.title || 'Untitled')}</div>
            <div class="item-meta">${escapeHtml(item.authors || 'No authors')}${item.year ? ` (${item.year})` : ''}</div>
            <div class="item-refs">${item.refCount} references in library</div>
          </li>
        `).join('');

        // Add click handlers via event delegation
        listEl.querySelectorAll('li[data-id]').forEach(li => {
          li.addEventListener('click', () => {
            const itemId = li.dataset.id;
            if (itemId) {
              selectItem(itemId);
            }
          });
        });
      }

      function filterList() {
        const query = document.getElementById('search-input').value.toLowerCase().trim();

        if (currentMode === 'citations') {
          if (!query) {
            renderItemList(allItems);
            return;
          }
          const filtered = allItems.filter(item =>
            (item.title && item.title.toLowerCase().includes(query)) ||
            (item.authors && item.authors.toLowerCase().includes(query))
          );
          renderItemList(filtered);
        } else if (currentMode === 'coauthorship') {
          if (!query) {
            renderAuthorList(allAuthors);
            return;
          }
          const filtered = allAuthors.filter(author =>
            author.name && author.name.toLowerCase().includes(query)
          );
          renderAuthorList(filtered);
        }
      }

      async function loadAuthors() {
        const listEl = document.getElementById('item-list');
        listEl.innerHTML = `
          <li class="loading">
            <div class="loading-spinner"></div>
            Loading authors...
          </li>
        `;

        try {
          const response = await fetch("/api/get-authors", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
          });

          if (!response.ok) {
            throw new Error(`HTTP error ${response.status}`);
          }

          const data = await response.json();
          allAuthors = data.authors;

          // Sort by paper count (descending), then by name
          allAuthors.sort((a, b) => {
            if (b.paperCount !== a.paperCount) {
              return b.paperCount - a.paperCount;
            }
            return a.name.localeCompare(b.name);
          });

          document.getElementById('list-header').textContent = `${allAuthors.length} authors`;
          renderAuthorList(allAuthors);
          updateLegendForCoauthorship();

        } catch (error) {
          console.error('Error loading authors:', error);
          listEl.innerHTML = `
            <div class="error">
              <strong>Error loading authors:</strong><br/>
              ${error.message}
            </div>
          `;
        }
      }

      function renderAuthorList(authors) {
        const listEl = document.getElementById('item-list');

        if (authors.length === 0) {
          listEl.innerHTML = '<li class="status-message">No matching authors</li>';
          return;
        }

        listEl.innerHTML = authors.map(author => `
          <li data-id="${escapeHtml(author.id)}">
            <div class="item-title">${escapeHtml(author.name)}</div>
            <div class="item-count">${author.paperCount} paper${author.paperCount !== 1 ? 's' : ''} in library</div>
          </li>
        `).join('');

        // Add click handlers
        listEl.querySelectorAll('li[data-id]').forEach(li => {
          li.addEventListener('click', () => {
            const authorId = li.dataset.id;
            if (authorId) {
              selectAuthor(authorId);
            }
          });
        });
      }

      async function selectAuthor(authorId) {
        console.log('Selecting author:', authorId);

        // Update selection in list
        document.querySelectorAll('.item-list li').forEach(li => {
          li.classList.toggle('selected', li.dataset.id === authorId);
        });

        selectedAuthorId = authorId;
        const author = allAuthors.find(a => a.id === authorId);

        if (!author) {
          console.error('Author not found:', authorId);
          return;
        }

        // Update graph header
        document.getElementById('graph-header').style.display = 'block';
        document.getElementById('graph-title').innerHTML = escapeHtml(author.name);
        document.getElementById('graph-subtitle').textContent =
          `${author.paperCount} paper${author.paperCount !== 1 ? 's' : ''} in library`;

        document.getElementById('graph-legend').style.display = 'flex';

        // Fetch co-authorship data
        try {
          console.log('Fetching co-authors for:', authorId);
          const response = await fetch("/api/get-coauthors", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ author_id: authorId }),
          });

          if (!response.ok) {
            throw new Error(`HTTP error ${response.status}`);
          }

          const coauthorData = await response.json();
          console.log('Got coauthor data:', coauthorData.nodes.length, 'coauthors');
          renderCoauthorGraph(author, coauthorData);

        } catch (error) {
          console.error('Error fetching coauthors:', error);
          renderCoauthorGraph(author, { nodes: [], edges: [] });
        }
      }

      function renderCoauthorGraph(centralAuthor, coauthorData) {
        console.log('renderCoauthorGraph called for:', centralAuthor.name);

        const elements = [];
        const nodeIds = new Set();

        // Add central node
        elements.push({
          data: {
            id: centralAuthor.id,
            label: centralAuthor.name,
            fullName: centralAuthor.name,
            paperCount: centralAuthor.paperCount,
            nodeType: 'central'
          }
        });
        nodeIds.add(centralAuthor.id);

        // Add coauthor nodes
        coauthorData.nodes.forEach(node => {
          if (!nodeIds.has(node.id)) {
            elements.push({
              data: {
                id: node.id,
                label: truncate(node.name, 20),
                fullName: node.name,
                paperCount: node.paperCount,
                sharedPapers: node.sharedPapers,
                nodeType: 'coauthor'
              }
            });
            nodeIds.add(node.id);
          }
        });

        // Add edges (undirected, with weight)
        coauthorData.edges.forEach((edge, i) => {
          if (nodeIds.has(edge.source) && nodeIds.has(edge.target)) {
            elements.push({
              data: {
                id: `edge-${i}`,
                source: edge.source,
                target: edge.target,
                weight: edge.weight
              }
            });
          }
        });

        console.log('Calling initCoauthorCytoscape with', elements.length, 'elements');
        initCoauthorCytoscape(elements);
      }

      function initCoauthorCytoscape(elements) {
        console.log('initCoauthorCytoscape called');

        try {
          const cyContainer = document.getElementById("cy");

          if (cy) {
            cy.destroy();
            cy = null;
          }

          // Find max weight for scaling edge widths
          const maxWeight = Math.max(1, ...elements
            .filter(e => e.data.weight)
            .map(e => e.data.weight));

          cy = cytoscape({
            container: cyContainer,
            elements: elements,
            style: [
              // Central author node
              {
                selector: 'node[nodeType = "central"]',
                style: {
                  "background-color": "#cc2936",
                  "border-width": "3px",
                  "border-color": "#333",
                  label: "data(label)",
                  "text-wrap": "wrap",
                  "text-max-width": "120px",
                  "font-size": "11px",
                  "font-weight": "bold",
                  "text-valign": "bottom",
                  "text-margin-y": "8px",
                  width: "50px",
                  height: "50px",
                },
              },
              // Coauthor nodes
              {
                selector: 'node[nodeType = "coauthor"]',
                style: {
                  "background-color": "#cc2936",
                  label: "data(label)",
                  "text-wrap": "wrap",
                  "text-max-width": "100px",
                  "font-size": "9px",
                  "text-valign": "bottom",
                  "text-margin-y": "5px",
                  width: "35px",
                  height: "35px",
                },
              },
              // Edges (undirected, width based on weight)
              {
                selector: "edge",
                style: {
                  width: function(ele) {
                    const weight = ele.data('weight') || 1;
                    // Scale width from 1 to 8 based on weight
                    return 1 + (weight / maxWeight) * 7;
                  },
                  "line-color": "#999",
                  "curve-style": "bezier",
                },
              },
            ],
            layout: {
              name: "concentric",
              concentric: function(node) {
                return node.data('nodeType') === 'central' ? 2 : 1;
              },
              levelWidth: function() { return 1; },
              minNodeSpacing: 50,
              padding: 30,
              animate: false,
            },
          });

          // Click handler for nodes
          cy.on("tap", "node", function (evt) {
            const node = evt.target;
            const data = node.data();
            showAuthorNodeInfo(data);
          });

          // Click on background to clear
          cy.on("tap", function (evt) {
            if (evt.target === cy) {
              hideNodeInfo();
            }
          });

          console.log('Coauthor Cytoscape initialized successfully');
        } catch (error) {
          console.error('Error initializing Coauthor Cytoscape:', error);
        }
      }

      function showAuthorNodeInfo(data) {
        const infoDiv = document.getElementById("node-info");
        document.getElementById("node-title").innerHTML = escapeHtml(data.fullName || data.label || "Unknown");
        document.getElementById("node-authors").textContent = `${data.paperCount || 0} papers in library`;
        document.getElementById("node-year").textContent = data.sharedPapers
          ? `${data.sharedPapers} shared paper${data.sharedPapers !== 1 ? 's' : ''}`
          : '';

        let typeText = data.nodeType === 'central' ? "Selected Author" : "Co-author";
        document.getElementById("node-type").textContent = typeText;

        infoDiv.style.display = "block";
      }

      async function selectItem(itemId) {
        console.log('Selecting item:', itemId);

        // Update selection in list
        document.querySelectorAll('.item-list li').forEach(li => {
          li.classList.toggle('selected', li.dataset.id === itemId);
        });

        selectedItemId = itemId;
        const item = allItems.find(i => i.id === itemId);

        if (!item) {
          console.error('Item not found:', itemId);
          return;
        }

        // Update graph header
        document.getElementById('graph-header').style.display = 'block';
        document.getElementById('graph-title').innerHTML = sanitizeHtml(truncate(item.title, 60));
        document.getElementById('graph-subtitle').textContent =
          `${item.authors || 'No authors'}${item.year ? ` (${item.year})` : ''}`;

        // Show loading state
        const emptyState = document.getElementById('empty-state');
        if (emptyState) {
          emptyState.style.display = 'none';
        }
        document.getElementById('graph-legend').style.display = 'flex';

        // Fetch citation data for this item
        try {
          console.log('Fetching citations for:', itemId);
          const response = await fetch("/api/get-item-citations", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ work_id: itemId }),
          });

          if (!response.ok) {
            throw new Error(`HTTP error ${response.status}`);
          }

          const citationData = await response.json();
          console.log('Got citation data:', citationData.nodes.length, 'nodes');
          renderGraph(item, citationData);

        } catch (error) {
          console.error('Error fetching citations:', error);
          // Still render the graph with just the central node if API fails
          renderGraph(item, { nodes: [], edges: [] });
        }
      }

      function renderGraph(centralItem, citationData) {
        console.log('renderGraph called for:', centralItem.title);
        console.log('Citation data:', citationData.nodes.length, 'nodes,', citationData.edges.length, 'edges');

        // Build elements array
        const elements = [];
        const nodeIds = new Set();

        // Add central node
        elements.push({
          data: {
            id: centralItem.id,
            label: truncate(stripHtml(centralItem.title), 30),
            fullTitle: centralItem.title,
            authors: centralItem.authors,
            year: centralItem.year,
            nodeType: 'central',
            isLibrary: true
          }
        });
        nodeIds.add(centralItem.id);

        // Add cited nodes from citation data
        citationData.nodes.forEach(node => {
          if (!nodeIds.has(node.id)) {
            const isInLibrary = libraryWorkIds.has(node.id);

            // For library items, get author data from allItems (Zotero data)
            let authors = node.authors || '';
            let title = node.title;
            let year = node.year;

            if (isInLibrary) {
              const libraryItem = allItems.find(i => i.id === node.id);
              if (libraryItem) {
                authors = libraryItem.authors || authors;
                title = libraryItem.title || title;
                year = libraryItem.year || year;
              }
            }

            elements.push({
              data: {
                id: node.id,
                label: truncate(stripHtml(title), 25),
                fullTitle: title,
                authors: authors,
                year: year,
                nodeType: isInLibrary ? 'library' : 'external',
                isLibrary: isInLibrary
              }
            });
            nodeIds.add(node.id);
          }
        });

        // Add edges
        citationData.edges.forEach((edge, i) => {
          if (nodeIds.has(edge.source) && nodeIds.has(edge.target)) {
            elements.push({
              data: {
                id: `edge-${i}`,
                source: edge.source,
                target: edge.target
              }
            });
          }
        });

        // Initialize or update Cytoscape
        console.log('Calling initCytoscape with', elements.length, 'elements');
        initCytoscape(elements);
      }

      function initCytoscape(elements) {
        console.log('initCytoscape called with', elements.length, 'elements');

        try {
          const cyContainer = document.getElementById("cy");

          // Clear empty state
          const emptyState = document.getElementById('empty-state');
          if (emptyState) {
            emptyState.style.display = 'none';
          }

          // Destroy existing instance
          if (cy) {
            console.log('Destroying existing cy instance');
            cy.destroy();
            cy = null;
          }

          cy = cytoscape({
            container: cyContainer,
            elements: elements,
          style: [
            // Central node (selected item) - large red with border
            {
              selector: 'node[nodeType = "central"]',
              style: {
                "background-color": "#cc2936",
                "border-width": "3px",
                "border-color": "#333",
                label: "data(label)",
                "text-wrap": "wrap",
                "text-max-width": "120px",
                "font-size": "11px",
                "font-weight": "bold",
                "text-valign": "bottom",
                "text-margin-y": "8px",
                width: "50px",
                height: "50px",
              },
            },
            // Library nodes (in Zotero) - red
            {
              selector: 'node[nodeType = "library"]',
              style: {
                "background-color": "#cc2936",
                label: "data(label)",
                "text-wrap": "wrap",
                "text-max-width": "100px",
                "font-size": "9px",
                "text-valign": "bottom",
                "text-margin-y": "5px",
                width: "35px",
                height: "35px",
              },
            },
            // External nodes (not in Zotero) - grey
            {
              selector: 'node[nodeType = "external"]',
              style: {
                "background-color": "#b0b0b0",
                "border-width": "1px",
                "border-color": "#888",
                label: "data(label)",
                "text-wrap": "wrap",
                "text-max-width": "90px",
                "font-size": "8px",
                "text-valign": "bottom",
                "text-margin-y": "3px",
                width: "28px",
                height: "28px",
              },
            },
            // Highlighted node
            {
              selector: "node.highlighted",
              style: {
                "border-width": "3px",
                "border-color": "#333",
              },
            },
            // Edges
            {
              selector: "edge",
              style: {
                width: 1.5,
                "line-color": "#999",
                "target-arrow-color": "#999",
                "target-arrow-shape": "triangle",
                "curve-style": "bezier",
                "arrow-scale": 0.8,
              },
            },
          ],
          layout: {
            name: "concentric",
            concentric: function(node) {
              // Central node in the middle, others in outer ring
              return node.data('nodeType') === 'central' ? 2 : 1;
            },
            levelWidth: function() { return 1; },
            minNodeSpacing: 50,
            padding: 30,
            animate: false,
          },
        });

        // Click handler for nodes - just show info, don't navigate
        cy.on("tap", "node", function (evt) {
          const node = evt.target;
          const data = node.data();

          // Show node info
          showNodeInfo(data);
        });

        // Click on background to clear
        cy.on("tap", function (evt) {
          if (evt.target === cy) {
            hideNodeInfo();
          }
        });

        console.log('Cytoscape initialized successfully');
        } catch (error) {
          console.error('Error initializing Cytoscape:', error);
        }
      }

      function showNodeInfo(data) {
        const infoDiv = document.getElementById("node-info");
        document.getElementById("node-title").innerHTML = sanitizeHtml(data.fullTitle || data.label || "Unknown");
        document.getElementById("node-authors").textContent = data.authors || "No authors";
        document.getElementById("node-year").textContent = data.year ? `Year: ${data.year}` : "";

        let typeText = "External Reference";
        if (data.nodeType === 'central') {
          typeText = "Selected Item";
        } else if (data.isLibrary) {
          typeText = "In Zotero Library";
        }
        document.getElementById("node-type").textContent = typeText;

        infoDiv.style.display = "block";
      }

      function hideNodeInfo() {
        document.getElementById("node-info").style.display = "none";
      }

      function truncate(str, maxLen) {
        if (!str) return "";
        return str.length > maxLen ? str.substring(0, maxLen - 3) + "..." : str;
      }

      function escapeHtml(str) {
        if (!str) return '';
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
      }

      function sanitizeHtml(str) {
        if (!str) return '';
        // Allow only safe formatting tags: b, i, em, strong, sub, sup
        // First escape everything, then unescape the safe tags
        const escaped = escapeHtml(str);
        // Restore safe tags
        return escaped
          .replace(/&lt;(\/?(b|i|em|strong|sub|sup))&gt;/gi, '<$1>');
      }

      function stripHtml(str) {
        if (!str) return '';
        // Remove HTML tags for plain text display (e.g., in graph labels)
        return str.replace(/<[^>]*>/g, '');
      }
    </script>
  </body>
</html>
